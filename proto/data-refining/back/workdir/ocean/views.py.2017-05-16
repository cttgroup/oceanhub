# ocean
import json
import random
import os
from datetime import datetime
from itertools import chain

from django.shortcuts import render
from django.core import serializers
from django.http import HttpResponse
import django_filters.rest_framework
from django.core.cache import cache
from django.test.utils import override_settings

from django.contrib.gis.geos import Point
from django.contrib.gis.db import models
from django.contrib.gis.geos import GEOSGeometry
from django.contrib.gis.geos import Polygon, MultiPolygon

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import generics

from .models import *
from .serializers import *


def test(request, anylink):
    response = HttpResponse()
    response.write("TEST<br />")
    response.write(anylink)
    return response

models = {
    'chlor': 'Chlorophyll',
    'sst': 'SST',
}


def api_get_queryset(model, _date, region, needed):
    # Returned result array
    result = []

    # Convert date to datetime format
    date = _date + ' 00:00:00'

    # Max number of DB selects have to be done
    select = 20  # select = int(select)

    # Number of points you need
    needed = int(needed)
    if needed < 500:
        needed = 500

    # Getting the region value
    try:
        region = Region.objects.get(slug=region)
    except:
        region = Region.objects.get(slug='default')

    # Generating query set cache key
    cacheKey = str(_date) + '-' + str(region.slug) \
        + '-' + str(model) \
        + '-' + str(needed) + '-' \
        + str(select)

    # Define main DB query, execution is delayed
    qsTotal = eval(model).objects.filter(
        datetime=date,
        point__intersects=region.mpoly,
    )

    # Total points found using query filter
    total = qsTotal.count()

    print("Total points found:", total)  # 4 testing

    # Exit if no points found
    if total < 1:
        print("No points found")
        return result

    # Getting points queryset
    # using normalization algorithm
    step = int(round(total / select, -1))
    pull = int(round(step / (total / needed), -1))
    randStep = step - pull
    randStep = randStep if randStep > 0 else step

    # Trying to get cached data
    result = cache.get(cacheKey)

    # If cache data in not set, making query
    if not result:
        result = []
        print("Making query...")
        for i in range(select):
            shift = i * step + random.randint(0, randStep)
            print("Query shift:", shift)
            qs = qsTotal.filter()[shift:shift + pull]
            result = list(chain(result, qs))
        cache.set(cacheKey, result)
    else:
        print("Got the cached data from memcached")

    print("Points selected:", len(result))

    # Writing jsoned data to file
    # with open(jsonFile, 'w') as f:
        # f.write(serializers.serialize("json", resultList))

    return result


def api_get_queryset2(model, _date, region, needed):
    # Returned data dictionary
    data = {"points": [], "meta": {}}
    # Convert date to datetime format
    date = _date + ' 00:00:00'
    # Max number of DB selects have to be done
    select = 20  # select = int(select)
    # Number of points you need
    needed = int(needed)
    if needed < 500:
        needed = 500
    # Getting the region value
    try:
        region = Region.objects.get(slug=region)
    except:
        region = Region.objects.get(slug='default')

    # Executing cached query
    qsTotalCacheKey = str(_date) + '-' + str(region.slug) + '-' + str(model)
    print("Trying to get queried points from cache for the key: ",
        qsTotalCacheKey)
    qsTotal = cache.get(qsTotalCacheKey)
    if not qsTotal:
        print("No cached points found, quering points using filter options...")
        # with override_settings(CACHALOT_ENABLED=False):
        qsTotal = eval(model).objects.filter(
            datetime=date,
            point__intersects=region.mpoly,
        )
        cache.set(qsTotalCacheKey, qsTotal)

    # Total points found using query filter
    total = qsTotal.count()
    # data["meta"]["found"] = total

    # Exit if no points found
    if total < 1:
        print("No points found")
        return []

    cacheHash = str(_date) + '-' + str(region.slug) + '-' + str(model) \
        + '-' + str(needed) + '-' + str(select)
    print("HASH", cacheHash)
    cacheKey = cacheHash

    # Result queried points list
    resultList = []

    # Getting points queryset using normalization algorithm
    print("Total points found:", total)
    step = int(round(total / select, -1))
    pull = int(round(step / (total / needed), -1))
    randStep = step - pull
    randStep = randStep if randStep > 0 else step

    """
    test = cache.get('test')
    if not test:
        print("SET TEST\n")
        cache.set('test', 'test value')
        test = cache.get('test')
    print("TEST VALUE", test)
    """

    result = cache.get(cacheKey)
    # print("RESULT", result)
    if not result:
        print("Making query...")
        for i in range(select):
            shift = i * step + random.randint(0, randStep)
            print("Query shift:", shift)
            qs = qsTotal.filter()[shift:shift + pull]
            resultList = list(chain(resultList, qs))
            # jsonedData = serializers.serialize("json", qs)
            result = resultList
        cache.set(cacheKey, result)
    # print("RESULT", result)

    # data["points"] = resultList
    # print("DATA", data)

    # Selected points found counter
    # data["meta"]["selected"] = len(resultList)
    print("Points selected:", len(result))

    # Writing jsoned data to file
    # with open(jsonFile, 'w') as f:
        # f.write(serializers.serialize("json", resultList))

    return result


class ApiChlor(generics.ListCreateAPIView):
    serializer_class = ChlorophyllSerializer

    def get_queryset(self):
        qs = api_get_queryset(
            'Chlorophyll',
            self.kwargs['date'],
            self.kwargs['region'],
            self.kwargs['needed'],
        )

        return qs


class ApiSST(generics.ListCreateAPIView):
    serializer_class = SSTSerializer

    def get_queryset(self):
        qs = api_get_queryset(
            'SST',
            self.kwargs['date'],
            self.kwargs['region'],
            self.kwargs['needed'],
        )

        return qs


class ApiBath(generics.ListCreateAPIView):
    serializer_class = BathymetricSerializer

    def get_queryset(self):
        qs = api_get_queryset(
            'Bathymetric',
            '2015-03-18',
            self.kwargs['region'],
            self.kwargs['needed'],
        )

        return qs


class RegionsList(generics.ListCreateAPIView):
    queryset = Region.objects.all()
    serializer_class = RegionSerializer


class RegionsDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = Region.objects.all()
    serializer_class = RegionSerializer



def get_points(request, date, region, characteristic, needed=1000,
    select=20):
    # variables declaration
    response = HttpResponse()
    response['Content-Type'] = "text/javascript; charset=utf-8"
    # select = 20  # max number of DB selects have to be done
    select = int(select)

    if request.method == 'GET':
        jsonFilePath = '/data/json/'
        if not os.path.exists(jsonFilePath):
            os.makedirs(jsonFilePath)
        jsonFile = jsonFilePath \
            + str(date) + '-' + region + '-' + characteristic \
            + '-' + str(needed) + '-' + str(select) + '.json'

        """
        if os.path.exists(jsonFile):
            with open(jsonFile) as jsonData:
                response.write(json.load(jsonData))
            # print(d)
            # response.write(d)
            return response
        """

        data = {"points": [], "meta": {}}
        totalPoints = 0
        region = Region.objects.get(slug=region)
        date = str(date) + ' 00:00:00'
        model = {
            'sst': 'SST',
            'chlor_a': 'Chlorophyll',
        }
        # needed = 1000  # number of points you need
        needed = int(needed)
        total = eval(model[characteristic]).objects.filter(
            datetime=date,
            point__intersects=region.mpoly,
        ).count()
        if total > 0:
            print("Total points found", total)
            step = int(round(total / select, -1))
            pull = int(round(step / (total / needed), -1))
            randStep = step - pull
            randStep = randStep if randStep > 0 else step

            for i in range(select):
                shift = i * step + random.randint(0, randStep)
                print("shift", shift)
                qs = eval(model[characteristic]).objects.filter(
                    datetime=date,
                    point__intersects=region.mpoly,
                )[shift:shift + pull]

                jsonedData = serializers.serialize("json", qs)

                redata = json.loads(jsonedData)
                counter = 0
                for point in redata:
                    lon = point["fields"]["point"].split(" ")[1][1:]
                    lat = point["fields"]["point"].split(" ")[2][:-1]
                    value = point["fields"][characteristic]
                    data["points"].append({
                        "lon": lon,
                        "lat": lat,
                        "value": value,
                    })
                    totalPoints += 1

        data["meta"]["selected"] = totalPoints
        data["meta"]["found"] = total
        out = json.dumps(data)
        response.write(json.dumps(data))

        # Writing jsoned data to file
        with open(jsonFile, 'w') as f:
            f.write(out)

        return response



"""
    # Writing jsoned data to file
    json_output = '/data/json/'
    if not os.path.exists(json_output):
        os.makedirs(json_output)
    with open(json_output + region + '.json', 'w') as f:
        f.write(out)



        # 4 testing
        counter += 1
        if counter > 100:
            break


    class SSTList(generics.ListCreateAPIView):
        queryset = SST.objects.all()
        serializer_class = SSTSerializer


    class SSTDetail(generics.RetrieveUpdateDestroyAPIView):
        queryset = SST.objects.all()
        serializer_class = SSTSerializer

    class ChlorFilter(django_filters.rest_framework.FilterSet):
        class Meta:
            model = Chlorophyll
            fields = ['datetime']


    class ChlorList(generics.ListCreateAPIView):
        queryset = Chlorophyll.objects.all()
        serializer_class = ChlorSerializer
        filter_class = ChlorFilter
"""
